---
title: 同步hexo博客内容到公众号
date: 2020-01-09 21:49:56
desc: 再hexo中编写好的博客文件，实现自动同步到公众号中。
tags: blog, WeChat
---

搞了公众号，想把hexo写的博客内容也同步到微信公众号中， 萌生了一个简单的项目，来实现它。

<!-- more -->

## 大致的思路

hexo 编写好的文档后， 推送到远程仓库， 仓库使用webhook通知服务器， 服务器脚本拉取最新代码后，

判断有没有新写的博客， 有的话， 使用markdown转化， 获取标题， 图片， 内容再要等等， 然后再公众号开放接口，

新增图文素材后，再服务器执行 hexo 编译，发布。

#### 代码常量列表

项目公共常量

```golang

// consts.go

package vxgo

const (
	appId       = "wx59bce618019e60cf"
	appSecret   = "********************************"
	gitRepo     = "https://github.com/loovien/blog-code.git"
	gitRepoName = "blog-code"
	workDir     = "/tmp"
)

const (
	imageType = "image"
	voiceType = "voice"
	videoType = "video"
	thumbType = "thumb"
)

const (
	addNewsURL      = "https://api.weixin.qq.com/cgi-bin/material/add_news?access_token=%s"
	accessTokenURL  = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=%s&secret=%s"
	materialURL     = "https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=%s&type=%s"
	imgUploadingURL = "https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=%s"
)

// models.go

package vxgo

type VxAccessToken struct {
	AccessToken string `json:"access_token"`
	ExpiresIn   int    `json:"expires_in"`
}

type VxNewsForm struct {
	Articles []VxNews `json:"articles"`
}

type VxNews struct {
	Title              string `json:"title"`
	ThumbMediaId       string `json:"thumb_media_id"`
	Authod             string `json:"authod"`
	ShowCoverPic       string `json:"show_cover_pic"`
	Digest             string `json:"digest"`
	Content            string `json:"content"`
	ContentSourceUrl   string `json:"content_source_url"`
	NeedOpenComment    uint32 `json:"need_open_comment"`
	OnlyFansCanComment uint32 `json:"only_fans_can_comment"`
}

type VxMaterial struct {
	URL     string `json:"url"`
	MediaId string `json:"media_id"`
}



```


#### 公众号推送

下面是实现公众号处理的一些方方法

```golang

package vxgo

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"sync"
	"time"
)

type VxNET struct {
	accessToken *VxAccessToken
}

var (
	vxNET     *VxNET
	VxNetOnce = &sync.Once{}
)

func GetVxNet() *VxNET {
	VxNetOnce.Do(func() {
		vxNET = &VxNET{
			accessToken: &VxAccessToken{},
		}
	})
	return vxNET
}

func (vn *VxNET) GetAccessToken() string {
	if vn.accessToken.ExpiresIn > int(time.Now().Unix()) {
		return vn.accessToken.AccessToken
	}
	tokenURL := fmt.Sprintf(accessTokenURL, VxCfg.AppId, VxCfg.AppSecret)
	response, err := http.Get(tokenURL)
	if err != nil {
		log.Printf("fetch WeChat access_token failure:%v\n", err)
		return ""
	}
	defer response.Body.Close()
	respBytes, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Printf("read access_token response failure: %#v\n", err)
		return ""
	}
	accessToken := &VxAccessToken{}
	err = json.Unmarshal(respBytes, accessToken)
	if err != nil {
		log.Printf("unmarshal access_token failure: %#v\n", err)
		return ""
	}
	vn.accessToken = &VxAccessToken{
		AccessToken: accessToken.AccessToken,
		ExpiresIn:   accessToken.ExpiresIn + int(time.Now().Unix()),
	}
	return accessToken.AccessToken
}

func (vn *VxNET) PostPersistentMaterial(fileName, filePath, typ string, params ...map[string]string) *VxMaterial {
	mURL := fmt.Sprintf(materialURL, vn.GetAccessToken(), typ)
	buffer := &bytes.Buffer{}
	partBody := multipart.NewWriter(buffer)

	part, err := partBody.CreateFormFile(fileName, filepath.Base(filePath))
	if err != nil {
		log.Fatalf("create multipart filePath failure: %#v\n", err)
	}
	fd, err := os.Open(filePath)
	if err != nil {
		log.Fatalf("post material to WeChat failure: %s err: %#v\n", filePath, err)
	}
	io.Copy(part, fd)
	fd.Close()
	if len(params) > 0 {
		for key, value := range params[0] {
			err = partBody.WriteField(key, value)
			if err != nil {
				log.Printf("write field: %s value: %s failure: %#v\n", key, value, err)
			}
		}
	}
	contentType := partBody.FormDataContentType()
	resp, err := http.Post(mURL, contentType, buffer)
	partBody.Close()
	if err != nil {
		log.Fatalf("send material request failure: %#v\n", err)
	}
	defer resp.Body.Close()
	respBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("read material request failure: %s err: %#v", string(respBytes), err)
	}
	material := &VxMaterial{}
	log.Printf("send material request success: %s\n", string(respBytes))
	err = json.Unmarshal(respBytes, material)
	if err != nil {
		log.Fatalf("post material response unmarshal failure: %v\n", err)
	}
	return material
}

func (vn *VxNET) PostVxNews(news VxNews) bool {
	newsUrl := fmt.Sprintf(addNewsURL, vn.GetAccessToken())
	vxNews := VxNewsForm{
		Articles: []VxNews{news},
	}
	newBytes, _ := json.Marshal(vxNews)
	formReader := bytes.NewReader(newBytes)
	response, err := http.Post(newsUrl, "application/json;charset=utf8", formReader)
	if err != nil {
		log.Printf("post news to WeChat failure: data:%#v,  err: %#v\n", vxNews, err)
		return false
	}
	defer response.Body.Close()
	respBytes, _ := ioutil.ReadAll(response.Body)
	log.Printf("post news to WeChat result: %s\n", string(respBytes))
	return true
}

func (vn *VxNET) UploadVxImg(paramName, file string) string {
	fd, err := os.Open(file)
	if err != nil {
		log.Fatalf("open file: %s failure: %v\n", file, err)
	}
	body := new(bytes.Buffer)
	part := multipart.NewWriter(body)
	partBody, err := part.CreateFormFile(paramName, filepath.Base(file))
	if err != nil {
		log.Fatalf("create form upload file failure: %v\n", err)
	}
	io.Copy(partBody, fd)
	fd.Close()
	part.Close()

	uploadURL := fmt.Sprintf(imgUploadingURL, vn.GetAccessToken())
	resp, err := http.Post(uploadURL, part.FormDataContentType(), body)
	if err != nil {
		log.Fatalf("request uploadimg: %s failure: %v\n", uploadURL, err)
	}
	respBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("read response failure: %v\n", err)
	}
	resp.Body.Close()
	log.Printf("request uploadimg success: %s\n", string(respBytes))

	type ImgUploadResp struct {
		URL string `json:"url"`
	}
	imgResp := new(ImgUploadResp)
	err = json.Unmarshal(respBytes, imgResp)
	if err != nil {
		log.Fatalf("json unmarshal failure: %v\n", err)
	}
	return imgResp.URL
}

```
